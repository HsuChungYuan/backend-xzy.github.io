<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[同类]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%90%8C%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;也许，我有点怪，如果你不介意的话没事，生而为人，谁都有点毛病的，我懂&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;不，你不懂是的，我不懂]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人语录（杂，持续更新）]]></title>
    <url>%2F2019%2F05%2F26%2F%E4%B8%AA%E4%BA%BA%E8%AF%AD%E5%BD%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有自己的意见和想法是一件再正常不过的事情，我们是人，不是机器如果我是怪人，那么世界上所有人都是怪人；如果我不是怪人，那么这个世界上就没有怪人]]></content>
  </entry>
  <entry>
    <title><![CDATA[领域驱动设计模式（持续更新）]]></title>
    <url>%2F2019%2F05%2F15%2F%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Ubiquitous Language&emsp;&emsp;通用语言 Model-Driven Design&emsp;&emsp;没看懂 Hands-On Modeler&emsp;&emsp;任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。任何 负责修改代码的人员则必须学会用代码来表达模型。每一个开发人员都必须不同程度地参与模型 讨论并且与领域专家保持联系。参与不同工作的人都必须有意识地通过UBIQUITOUS LANGUAGE 与接触代码的人及时交换关于模型的想法。 Layered ArchitectureThe Smart UIEntity（又称为 Reference Object）ServiceModule（也称为 Package）AggregateFactoryRepositorySpecificationIntention-Revealing InterfaceSide-Effect-Free FunctionAssertionConceptual ContourStandalone ClassClosure Of OperationStrategy（也成为 Policy）CompositeBounded ContextContinuous IntegrationContext MapShared KernelCustomer/Supplier Development TeamConformistAnticorruption LayerSeparate WayOpen Host ServicePublished LanguageCore DomainGeneric SubdomainDomain Version StatementHighlighted CoreCohesive MechanismSegregated CoreAbstract CoreEvolving OrderSystem MetaphorResponsibility LayerKnowledge LevelPluggable Component Framework]]></content>
  </entry>
  <entry>
    <title><![CDATA[思想比API更重要]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%80%9D%E6%83%B3%E6%AF%94API%E6%9B%B4%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[恐怖的事实&emsp;&emsp;我不知道其他学校是怎么样的，就我所在的一所二本院校而言，软件工程专业，已几乎成为API教学。&emsp;&emsp;背后的原因是什么我不想深究，很复杂。但是如果作为一名有追求的软件设计者，我认为抛开设计思想只学习API是写不好代码的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[你是否误用了RESTful风格中面向资源的特点]]></title>
    <url>%2F2019%2F04%2F21%2F%E4%BD%A0%E6%98%AF%E5%90%A6%E8%AF%AF%E7%94%A8%E4%BA%86RESTful%E9%A3%8E%E6%A0%BC%E4%B8%AD%E9%9D%A2%E5%90%91%E8%B5%84%E6%BA%90%E7%9A%84%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[什么是 RESTful 风格&emsp;&emsp;本文主要讨论 RESTful 面向资源这一条，基础概念这里不多做介绍，不了解的请自行搜索 RESTful 的介绍 RESTful 最佳实践&emsp;&emsp;阮一峰参考相关资料写出的RESTful最佳实践 回归正题&emsp;&emsp;在设计后台接口的时候，有些接口很难使用面向资源的风格去进行设计，比如发送短信验证码和校验验证码的接口。&emsp;&emsp;实际上把这种接口强行用面向资源的风格去进行设计是对 RESTful 面向资源的特点的误用。&emsp;&emsp;为什么这么说呢？因为有些接口“不是资源”，那强行使用面向资源的风格去进行设计只会带来麻烦。]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解 JWT 的使用场景和优劣]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JWT%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E4%BC%98%E5%8A%A3%2F</url>
    <content type="text"><![CDATA[深入理解 JWT 的使用场景和优劣深入理解 JWT 的使用场景和优劣]]></content>
      <categories>
        <category>JWT</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String.intern 深入研究]]></title>
    <url>%2F2019%2F04%2F12%2FString-intern%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[String.intern 深入研究点击了解详情]]></content>
      <categories>
        <category>Java拾遗</category>
      </categories>
      <tags>
        <tag>Java拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人学习路线]]></title>
    <url>%2F2019%2F04%2F12%2F%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[大一上 C学到链表 大一下 数据结构和算法入门 Linux 入门 数据库入门 JavaSE 入门 大二上 JavaWeb 入门 Hibernate Spring 全家桶学到 SpringBoot 图解 HTTP JWT至此已经能快速开发简单的后台项目了 大二下（进行中） SpringCloud 简单了解 docker 简单了解（还无法熟练使用） JavaSE 重新筑基（Thinking in Java） 深入理解 Java 虚拟机]]></content>
  </entry>
  <entry>
    <title><![CDATA[Semaphore详解]]></title>
    <url>%2F2019%2F04%2F10%2FSemaphore%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Semaph详解点击了解详情]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名内部类的隐式final参数]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8Ffinal%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;标题原文：为什么匿名内部类只能使用final修饰的局部变量。但是在写博文的过程中，发现这句话其实是根本不对的，故将标题改为“匿名内部类的隐式final参数”。 1 一句话概念&emsp;1.1 什么是匿名内部类&emsp;&emsp;&emsp;匿名内部类就是定义在方法中的类。 &emsp;1.2 什么是局部变量&emsp;&emsp;&emsp;局部变量就是在方法中被声明的变量。 2 匿名内部类代码示例不使用局部变量的匿名类12345678910111213141516public interface Interface &#123; public void function();&#125;class test &#123; public static void main(String[] args) &#123; //匿名类定义开始 Interface intface = new Interface() &#123; @Override public void function() &#123; &#125; &#125;;//匿名类定义结束 &#125;&#125; 3 问题导读 正常的类应该使用定义在其他方法中的局部变量吗？ 匿名内部类可以使用它外层方法里定义的局部变量吗？ 匿名内部类中使用的变量真的是外层方法的局部变量吗？ 4 匿名内部类代码示例使用了局部变量的匿名内部类，给人的感觉非常自然1234567891011121314151617public interface Interface &#123; public void function();&#125;class test &#123; public static void main(String[] args) &#123;+ String local = "This is a local variable."; //匿名类定义开始 Interface intface = new Interface() &#123; @Override public void function() &#123;+ System.out.println(local); &#125; &#125;;//匿名类定义结束 &#125;&#125; 5 分析&emsp;&emsp;对于普通类来说，使用定义在其他方法中的局部变量简直是不可理喻的事情；但是对于匿名内部类来说却又是看起来很正常的事，毕竟这个类完全被外层方法包裹了，能使用外层方法里的局部变量不是很理所应当的吗？&emsp;&emsp;这好像就得出结论了，普通类不能使用定义在其他方法中的局部变量，而匿名内部类可以使用定义在外层方法中的局部变量。 6 匿名内部类中使用的变量真的是外层方法的局部变量吗？&emsp;&emsp;众所周知，局部变量是保存在栈中的，而对象内的变量是保存在堆中的，所以匿名内部类中使用的变量不是外层方法的局部变量。实际上匿名内部类中所使用的外部方法中的局部变量，全部都是对于原先局部变量的拷贝，这其实也就是之前所学的函数传参的原理。 7 那final呢？上文所述可以解释隐式和参数这两个关键词，但是final又是什么鬼？别急，我们先来看一段代码不能通过编译的代码123456789101112131415161718public interface Interface &#123; public void function();&#125;class test &#123; public static void main(String[] args) &#123; String local = "This is a local variable."; //匿名类定义开始 Interface intface = new Interface() &#123; @Override public void function() &#123;+ local = "I want to change the variable, but i cannot"; System.out.println(local); &#125; &#125;;//匿名类定义结束 &#125;&#125; &emsp;&emsp;在新增加的语句处会编译报错，报错信息：Variable &#39;local&#39; is accessed from within inner class, needs to be final or effectively final.&emsp;&emsp;翻译：变量local在内部类中被访问，需要是final的或者是effectively final的。effectively final就是说如果你永远不修改变量的值，那这个变量就是等价于是final的，这是JDK8增加的新特性。 8 那为什么是final的呢？不是final的不行吗？&emsp;&emsp;现在我们知道了匿名内部类中的隐式参数是final的，但是我们并不知道为什么隐式参数是final的。&emsp;&emsp;其实吧，这个final是为了保证数据一致性。不理解？没关系，我们来看下一段代码假设这段代码能够通过编译1234567891011121314151617public interface Interface &#123; public void function();&#125;class test &#123; public static void main(String[] args) &#123; String local = "This is a local variable."; //匿名类定义开始 Interface intface = new Interface() &#123; @Override public void function() &#123; local = "I want to change the variable, but i cannot"; System.out.println(local); &#125; &#125;;//匿名类定义结束 &#125; &#125; &emsp;&emsp;在分析之前，再提一下关键点 这里实际上有两个local变量，而非一个 Java设计者希望造成一种错觉，让人们误以为只有一个local变量（这就要求两个变量的数据要一致） &emsp;&emsp;分析：运行至12行，内部类中的local变量被改变了，这就导致两个local变量的值不一样，违背了Java的设计要求，所以Java设计者们规定隐式参数为final来保证数据一致性]]></content>
      <categories>
        <category>Java拾遗</category>
      </categories>
      <tags>
        <tag>Java拾遗</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的API与SPI]]></title>
    <url>%2F2019%2F04%2F03%2FJava%E4%B8%AD%E7%9A%84API%E4%B8%8ESPI%2F</url>
    <content type="text"><![CDATA[点解了解SPI]]></content>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两行代码搞定Base64编码]]></title>
    <url>%2F2019%2F04%2F03%2F%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9ABase64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[两行代码搞定Base64编码123456import java.util.Base64;//拿到Base64编码器Base64.Encoder encoder = Base64.getEncoder();//通过编码器拿到Base64编码后的字符串String base64Result = encoder.encodeToString("要加密的东西，不一定是字符串".getBytes());]]></content>
      <tags>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三行代码搞定MD5加密]]></title>
    <url>%2F2019%2F04%2F03%2F%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%90%9E%E5%AE%9AMD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[三行代码搞定MD5加密12345678import org.apache.tomcat.util.buf.HexUtils;import java.security.MessageDigest;//获得MD5加密类实例MessageDigest md = MessageDigest.getInstance("MD5");md.update("要加密的字符串".getBytes("UTF-8"));//得到32位的16进制字符串结果String hexResult = HexUtils.toHexString(md.digest());]]></content>
      <tags>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每天一个设计模式——六大设计原则]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[单一职责原则职责拆分要够细，一个类只有一个职责 里氏替换原则所有父类能够被替换为子类 即我们能够为子类添加新的方法，但尽量不要重写父类的方法 依赖倒置原则即面向接口编程的设计思想 接口隔离原则这是接口设计的要求，要求一个接口只包含它应该包含的方法，不要编写包含很多杂乱的方法的接口，以至于本来不应该有关系的类通过实现臃肿的接口产生联系 迪米特原则即高内聚，低耦合的设计思想 开闭原则对扩展开放，对修改封闭]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是怎么走Java后端这条路的——大二篇]]></title>
    <url>%2F2019%2F03%2F31%2F%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0Java%E5%90%8E%E7%AB%AF%E8%BF%99%E6%9D%A1%E8%B7%AF%E7%9A%84%E2%80%94%E2%80%94%E5%A4%A7%E4%BA%8C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[萌新在进入大学前，我几乎没有接触过编程（除了初中还是小学的时候学过几行HTML/CSS）。对于一个超级小白来说，确立学习方向和快速入门是头等大事。 学校教学大学学习靠自己，这句话一点都没有错。我不知道其他好学校是不是这样，但是据我在二本院校的体验，很多专业课老师的教学跟混差不多，学生混，老师也混。我不是说所有老师都不好，但是那些非常重要的课程，一门都不能落下，在不积极自学的情况下，再摊上一个或几个混的老师，那还不完蛋？尤其对于编程这种需要综合知识的，那些短板是真的会拖后腿的。 入门编程学校课程的入门语言是C语言，易学但难用，再加上学校本来也只是把C作为萌新入门语言，学习了半年多之后就放弃了。在接下来的C++，python，Java中，我为什么选择了Java作为主要学习语言呢？ Java后端之旅我不仅学习过Java，也学习过C++和python。我选择Java不是因为Java比这二者更好，也不只是因为我更喜欢Java，最主要的原因是我当时只有Java的低价质高的系列课程。对于萌新而言，一条成体系的、没有沟壑的路是非常非常重要的。在此po出发哥的JavaWeb系列课程从不用框架的JSP、servlet和JDBC的传统mvc demo，到Spring Framework、Spring MVC等Spring全家桶框架，钟洪发老师帮我快速地建立起了JavaWeb的一套知识框架。知识体系建立之后就是真正考验自学能力的时候了，所谓师傅领进门，修行在个人。无论是JavaSE深入学习，还是数据库优化，还是自学多种产品，都需要自己去努力。 博客萌新，写作萌新。其实也没啥好写的，毕竟没啥经历也没啥技术积淀，纯粹是心血来潮想要搞个个人博客哈哈。不过既能锻炼自己的语言组织能力、写作能力，也能记录自己的经历，还能用做笔记，分享交友，一举多得，何乐而不为？语言较为稚嫩，毕竟我本来也没练过写作，还望多多见谅]]></content>
  </entry>
</search>
